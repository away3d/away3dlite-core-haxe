package away3dlite.loaders;import away3dlite.animators.frames.Frame;import away3dlite.animators.MovieMesh;import away3dlite.core.utils.Cast;#if haxe_206import flash.errors.Error;#elseimport flash.Error;#endimport flash.Lib;import flash.utils.ByteArray;import flash.utils.Endian;import flash.Vector;//use namespace arcane;using away3dlite.namespace.Arcane;using away3dlite.haxeutils.HaxeUtils;/*** File loader for the Md2 file format.*/class MD2 extends AbstractParser{	/** @private */	/*arcane*/ private override function prepareData(data:Dynamic):Void	{		md2 = Cast.bytearray(data);				var a:Int, b:Int, c:Int, ta:Int, tb:Int, tc:Int, i1:Int, i2:Int, i3:Int;		var i:Int;		var uvs:Array<Float> = [];				// Make sure to have this in Little Endian or you will hate you life.		// At least I did the first time I did this for a while.		md2.endian = Endian.LITTLE_ENDIAN;		// Read the header and make sure it is valid MD2 file		readMd2Header(md2);		if (ident != 844121161 || version != 8)			throw new Error("Error loading MD2 file: Not a valid MD2 file/bad version");		// UV coordinates		//		Load them!		md2.position = offset_st;		i = -1;		while (++i < num_st)		{			uvs.push(md2.readShort() / skinwidth); uvs.push((md2.readShort() / skinheight));		}					mesh.arcaneNS()._uvtData.length = mesh.arcaneNS()._vertices.length = num_tris*9;		vertices.length = num_tris*3;				// Faces		//		Creates the faces with the proper references to vertices		//		NOTE: DO NOT change the order of the variable assignments here, 		//			  or nothing will work.		md2.position = offset_tris;		i = -1;		while (++i < num_tris)		{			i1 = i*3;			i2 = i1 + 1;			i3 = i1 + 2;						//collect vertices			a = md2.readUnsignedShort();			b = md2.readUnsignedShort();			c = md2.readUnsignedShort();			vertices[i1] = a;			vertices[i2] = b;			vertices[i3] = c;						//var _mesh_arcane = mesh.arcaneNS();						//collect indices			mesh.arcaneNS()._indices.push3(i3, i2, i1);						//collect face lengths			mesh.arcaneNS()._faceLengths.push(3);						//collect uvData 			ta = md2.readUnsignedShort();			tb = md2.readUnsignedShort();			tc = md2.readUnsignedShort();						mesh.arcaneNS()._uvtData[i1*3] = uvs[ta*2];			mesh.arcaneNS()._uvtData[i1*3 + 1] = uvs[ta*2 + 1];			mesh.arcaneNS()._uvtData[i1*3 + 2] = 1;			mesh.arcaneNS()._uvtData[i2*3] = uvs[tb*2];			mesh.arcaneNS()._uvtData[i2*3 + 1] = uvs[tb*2 + 1];			mesh.arcaneNS()._uvtData[i2*3 + 2] = 1;			mesh.arcaneNS()._uvtData[i3*3] = uvs[tc*2];			mesh.arcaneNS()._uvtData[i3*3 + 1] = uvs[tc*2 + 1];			mesh.arcaneNS()._uvtData[i3*3 + 2] = 1;		}				// Frame animation data		//		This part is a little funky.		md2.position = offset_frames;		readFrames(md2);				//setup vertices for the first frame		i = mesh.arcaneNS()._vertices.length;		vertices = mesh.frames[0].vertices;		while (i-- != 0)			mesh.arcaneNS()._vertices[i] = vertices[i];				if (material != null)			mesh.material = material;				mesh.arcaneNS().buildFaces();				mesh.type = ".Md2";	}		private var md2:ByteArray;	private var ident:Int;	private var version:Int;	private var skinwidth:Int;	private var skinheight:Int;	private var framesize:Int;	private var num_skins:Int;	private var num_vertices:Int;	private var num_st:Int;	private var num_tris:Int;	private var num_glcmds:Int;	private var num_frames:Int;	private var offset_skins:Int;	private var offset_st:Int;	private var offset_tris:Int;	private var offset_frames:Int;	private var offset_glcmds:Int;	private var offset_end:Int;	private var mesh:MovieMesh;	private var vertices:Vector<Float>;	private var minX:Float;	private var maxX:Float;	private var minY:Float;	private var maxY:Float;	private var minZ:Float;	private var maxZ:Float;		/**	 * Reads in all the frames	 */	private function readFrames(data:ByteArray):Void	{		var sx:Float, sy:Float, sz:Float;		var tx:Float, ty:Float, tz:Float;		var fvertices:Vector<Float>, frame:Frame;		var tvertices:Vector<Float>;		var i:Int, j:Int, k:Int, char:Int;				i = -1;		while (++i < num_frames)		{			tvertices = new Vector<Float>();			fvertices = new Vector<Float>(num_tris*9, true);			frame = new Frame("", fvertices);			sx = data.readFloat();			sy = data.readFloat();			sz = data.readFloat();			tx = data.readFloat();			ty = data.readFloat();			tz = data.readFloat();						//read frame name			k = 0;			j = -1;			while (++j < 16)			{				char = data.readUnsignedByte();								if (Std.int(char) >= 0x30 && Std.int(char) <= 0x7A && k < 3)					frame.name += String.fromCharCode(char);								if (Std.int(char) >= 0x30 && Std.int(char) <= 0x39)					k++; 			}						// Note, the extra data.position++ in the for loop is there 			// to skip over a byte that holds the "vertex normal index"			j = -1;			while (++j < num_vertices)			{								tvertices.push3((sx * data.readUnsignedByte() + tx) * scaling, (sy * data.readUnsignedByte() + ty) * scaling, (sz * data.readUnsignedByte() + tz) * scaling);				data.position++;			}						j = -1;			while (++j < num_tris * 3)			{				fvertices[j*3] = tvertices[Std.int(vertices[j]*3)];				fvertices[j*3 + 1] = tvertices[Std.int(vertices[j]*3 + 1)];				fvertices[j * 3 + 2] = tvertices[Std.int(vertices[j] * 3 + 2)];								//collect min/max for 1 frame only				if (centerMeshes && i==0)				{					minX = (fvertices[j*3]<minX)?fvertices[j*3]:minX;					minY = (fvertices[j*3+1]<minY)?fvertices[j*3+1]:minY;					minZ = (fvertices[j*3+2]<minZ)?fvertices[j*3+2]:minZ;					maxX = (fvertices[j*3]>maxX)?fvertices[j*3]:maxX;					maxY = (fvertices[j*3+1]>maxY)?fvertices[j*3+1]:maxY;					maxZ = (fvertices[j*3+2]>maxZ)?fvertices[j*3+2]:maxZ;				}			}						mesh.addFrame(frame);						if (centerMeshes)				for (j  in 0...(num_tris*3)) 				{					fvertices[j*3] -= (maxX + minX)/2;					fvertices[j*3 + 1] -= (maxY + minY)/2;					fvertices[j*3 + 2] -= (maxZ + minZ)/2;				}					}				vertices.fixed = true;	}	/**	 * Reads in all that MD2 Header data that is declared as private variables.	 * I know its a lot, and it looks ugly, but only way to do it in Flash	 */	private function readMd2Header(data:ByteArray):Void	{		ident = data.readInt();		version = data.readInt();		skinwidth = data.readInt();		skinheight = data.readInt();		framesize = data.readInt();		num_skins = data.readInt();		num_vertices = data.readInt();		num_st = data.readInt();		num_tris = data.readInt();		num_glcmds = data.readInt();		num_frames = data.readInt();		offset_skins = data.readInt();		offset_st = data.readInt();		offset_tris = data.readInt();		offset_frames = data.readInt();		offset_glcmds = data.readInt();		offset_end = data.readInt();	}		/**	 * A scaling factor for all geometry in the model. Defaults to 1.	 */	public var scaling:Float;		/**	 * Controls the automatic centering of geometry data in the model, improving culling and the accuracy of bounding dimension values.	 */	public var centerMeshes:Bool;		/**	 * Creates a new <code>Md2</code> object.	 */	public function new()	{		super();				minX = minY = minZ = Math.POSITIVE_INFINITY;		maxX = maxY = maxZ = Math.NEGATIVE_INFINITY;				vertices = new Vector<Float>();		mesh = Lib.as(_container = new MovieMesh(), MovieMesh);		scaling = 1;				binary = true;	}}