package away3dlite.loaders{    import away3dlite.arcane;    import away3dlite.core.utils.Cast;	import away3dlite.containers.ObjectContainer3D;	import away3dlite.core.base.*;	import away3dlite.loaders.data.*;	import away3dlite.materials.BitmapFileMaterial;	import flash.geom.Vector3D;	import flash.geom.Matrix3D;	use namespace arcane;	    /**    * File loader/parser for the native .awd data file format.<br/>    */	    public class AWData extends AbstractParser    {		private var objs:Array = [];		private var geos:Array = [];		private var oList:Array =[];		private var aC:Array = [];		private var resolvedP:String = "";		private var url:String = "";		private var customPath:String = "";		     	/** @private */        arcane override function prepareData(data:*):void        {        	var awdData:String = Cast.string(data);			var lines:Array = awdData.split('\n');			if(lines.length == 1) lines = awdData.split(String.fromCharCode(13));			var trunk:Array;			var state:String = "";			var isMesh:Boolean;			var isMaterial:Boolean;			var id:int = 0;			var buffer:int=0;			var oData:Object;			var dline:Array;			var m:Matrix3D;			var cont:ObjectContainer3D;			var i:uint;			var version:String = "";			            for each (var line:String in lines)            {					if(line.substring(0,1) == "#" && state != line.substring(0,2)){						state = line.substring(0,2);						id = 0;						buffer = 0;												if(state == "#v")							version = line.substring(3,line.length-1);													if(state == "#f"){							isMaterial = (parseInt(line.substring(3,4)) == 2) as Boolean;							resolvedP = "";							if(isMaterial){								if(customPath != ""){									resolvedP = customPath;								} else if(url != ""){									var pathArray:Array = url.split("/");									pathArray.pop();									resolvedP = (pathArray.length>0)?pathArray.join("/")+"/":pathArray.join("/");								}							}						}													if(state == "#t")							isMesh = (line.substring(3,7) == "mesh") as Boolean;						 						continue;					}										dline = line.split(",");										if(dline.length <= 1)						continue;						 					if(state == "#o"){												if(buffer == 0){								id = dline[0];								m = new Matrix3D(new Vector.<Number>([parseFloat(dline[1]),parseFloat(dline[5]),parseFloat(dline[9]),parseFloat(dline[2]),parseFloat(dline[6]),parseFloat(dline[10]),parseFloat(dline[3]),parseFloat(dline[7]),parseFloat(dline[11]),parseFloat(dline[4]),parseFloat(dline[8]),parseFloat(dline[12]),0,0,0,1]));								++buffer;						} else {								m.position = new Vector3D(parseFloat(dline[9]),parseFloat(dline[10]),parseFloat(dline[11]));								oData = {name:(dline[0] == "")? "m_"+id: dline[0] ,											transform:m,											container:parseInt(dline[4]),											bothsides:(dline[5] == "true")? true : false,											sortType: (dline[7] == "false" && dline[8] == "false")? SortType.CENTER : ((dline[7] == "true")? SortType.FRONT : SortType.BACK),											material:(isMaterial && dline[12] != null && dline[12] != "")? resolvedP+((customPath != "")? dline[12].substring(7, dline[12].length):dline[12]) : null};																			objs.push(oData);								buffer = 0;						}											}										if(state == "#d"){												switch(buffer){							case 0:								id = geos.length;								geos.push({});								++buffer;								geos[id].aVstr = line.substring(2,line.length);								break;															case 1:								geos[id].aUstr = line.substring(2,line.length);								geos[id].aV= read(geos[id].aVstr).split(",");								geos[id].aU= read(geos[id].aUstr).split(",");								++buffer;								break;															case 2:								geos[id].f= line.substring(2,line.length);								buffer = 0;								objs[id].geo = geos[id];						}											}																	if(state == "#c" && !isMesh){						 						id = parseInt(dline[0]);						cont = new ObjectContainer3D();						m = new Matrix3D(new Vector.<Number>([parseFloat(dline[1]),parseFloat(dline[5]),parseFloat(dline[9]),parseFloat(dline[2]),parseFloat(dline[6]),parseFloat(dline[10]),parseFloat(dline[3]),parseFloat(dline[7]),parseFloat(dline[11]),parseFloat(dline[4]),parseFloat(dline[8]),parseFloat(dline[12]),0,0,0,1]));						cont.transform.matrix3D = m;						cont.name = (dline[13] == "null" || dline[13] == undefined)? "cont_"+id: dline[13];						 						aC.push(cont);						 						if(aC.length > 1)							aC[0].addChild(cont);					}						            }			 			var ref:Object;			var mesh:Mesh;			var j:int;			var av:Array;			var au:Array;			var aRef:Array;			var index:int;			 			for(i = 0;i<objs.length;++i){				 				ref = objs[i];				index = 0;				if(ref != null){					mesh = new Mesh();					mesh.type = "awd";					mesh.bothsides = ref.bothsides;					mesh.name = ref.name;					mesh.transform.matrix3D = ref.transform;					mesh.sortType = ref.sortType;					 					mesh.material = (ref.material == null)? ref.material : new BitmapFileMaterial(ref.material);										if(ref.container != -1 && !isMesh)						aC[ref.container].addChild(mesh);					aRef = ref.geo.f.split(",");					for(j = 0;j<aRef.length;j+=6){						av = ref.geo.aV[parseInt(aRef[j], 16)].split("/");						mesh._vertices.push(parseFloat(av[0]), -(parseFloat(av[1])), parseFloat(av[2]));						av = ref.geo.aV[parseInt(aRef[j+1],16)].split("/");						mesh._vertices.push(parseFloat(av[0]), -(parseFloat(av[1])), parseFloat(av[2]));						av = ref.geo.aV[parseInt(aRef[j+2],16)].split("/");						mesh._vertices.push(parseFloat(av[0]), -(parseFloat(av[1])), parseFloat(av[2]));						mesh._indices.push(index, index+1, index+2);						index+=3;						au = ref.geo.aU[parseInt(aRef[j+3],16)].split("/");						mesh._uvtData.push(parseFloat(au[0]), 1-parseFloat(au[1]), 0);						au = ref.geo.aU[parseInt(aRef[j+4],16)].split("/");						mesh._uvtData.push(parseFloat(au[0]), 1-parseFloat(au[1]), 0);						au = ref.geo.aU[parseInt(aRef[j+5],16)].split("/");						mesh._uvtData.push(parseFloat(au[0]), 1-parseFloat(au[1]), 0);					} 					mesh.buildFaces();				}			}						_container = isMesh? mesh : aC[0];			cleanUp();		}				private function cleanUp():void		{			for(var i:int = 0;i<objs.length;++i){				objs[i] == null;			}			objs = geos = oList = aC = null;		}				private function read(str:String):String		{			var start:int= 0;			var chunk:String;			var end:int= 0;			var dec:String = "";			var charcount:int = str.length;			for(var i:int = 0;i<charcount;++i){				if (str.charCodeAt(i)>=44 && str.charCodeAt(i)<= 48 ){					dec+= str.substring(i, i+1);				}else{					start = i;					chunk = "";					while(str.charCodeAt(i)!=44 && str.charCodeAt(i)!= 45 && str.charCodeAt(i)!= 46 && str.charCodeAt(i)!= 47 && i<=charcount){						i++;					}					chunk = ""+parseInt("0x"+str.substring(start, i), 16 );					dec+= chunk;					i--;				}			}			return dec;		}		 		/**		 * Creates a new <code>AWData</code> object, a parser for .awd files.		 * @see away3dlite.loaders.AWData#load()		 * @see away3dlite.loaders.AWData#parse()		 */		public function AWData(){}		/**		* Parses and creates an Object3D from the raw ascii data of an .awd file. The Away3D native.awd data files.		* Exporters to awd format are available in Away3d exporters package and in PreFab3D export options		* 		* @param	data				The ascii data of a .awd file.		* @param	data				[optional] If the url for the source materials muts be changed.		* Standard urls set for image sources from Prefab3D awd exports is "images/filename.jpg"		* Example:		* [Embed(source="aircraft/Aircraft.awd", mimeType="application/octet-stream")] 		* private var Aircraft:Class;		* [...] awaylite code		* var myoutput:Object3D = AWData.parse(new Aircraft(), "mydisc/myfiles/");//path becomes then "mydisc/myfiles/filename.jpg"		* scene.addChild(myoutput);		* 		* @return						An Object3D representation of the .awd file.		*/        public static function parse(data:*, sourcesUrl:String = ""):Object3D        {				data = Cast.string(data);			var parser:AWData = new AWData();						if(sourcesUrl != "")				parser.pathToSources = sourcesUrl;							parser.prepareData(data);			            return parser._container;        }    	 		/**		* Allows to set custom path to source(s) map(s) other than set in file		* Standard output url from Prefab awd files is "images/filename.jpg"		* when set pathToSources, url becomes  [newurl]filename.jpg.		* Example: AWData.pathToSources = "mydisc/myfiles/";		* Only required for load method using Loader3D		* var awd:AWData = new AWData();		* awd.pathToSources = "mydisc/myfiles/";		* loader = new Loader3D();		* loader.addEventListener(Loader3DEvent.LOAD_SUCCESS, onSuccess);		* loader.loadGeometry("mymodels/car.awd", awd);		*		*/		public function set pathToSources(url:String):void		{			customPath = url;		}    }}