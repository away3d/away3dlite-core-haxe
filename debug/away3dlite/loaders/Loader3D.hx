package away3dlite.loaders;import away3dlite.containers.ObjectContainer3D;import away3dlite.core.base.Mesh;import away3dlite.core.base.Object3D;import away3dlite.events.Loader3DEvent;import away3dlite.events.ParserEvent;import away3dlite.haxeutils.FastStd;import away3dlite.loaders.data.ContainerData;import away3dlite.loaders.data.MaterialData;import away3dlite.loaders.utils.TextureLoader;import away3dlite.loaders.utils.TextureLoadQueue;import flash.events.Event;import flash.events.IOErrorEvent;import flash.events.ProgressEvent;import flash.Lib;import flash.net.URLLoader;import flash.net.URLRequest;import flash.net.URLLoaderDataFormat;			//use namespace arcane;using away3dlite.namespace.Arcane;/** * Dispatched when the 3d object loader completes a file load successfully. *  * @eventType away3dlite.events.Loader3DEvent *///[Event(name="loadSuccess",type="away3dlite.events.Loader3DEvent")]			 /** * Dispatched when the 3d object loader fails to load a file. *  * @eventType away3dlite.events.Loader3DEvent *///[Event(name="loadError",type="away3dlite.events.Loader3DEvent")]			 /** * Dispatched when the 3d object loader progresses in the laoding of a file. *  * @eventType away3dlite.events.Loader3DEvent *///[Event(name="loadProgress",type="away3dlite.events.Loader3DEvent")]/** * Abstract loader class used as a placeholder for loading 3d content */class Loader3D extends ObjectContainer3D{   	public var parser:AbstractParser;	   	private var _object:Object3D;	private var _result:Object3D;	private var _bytesLoaded:Int;	private var _bytesTotal:Int;	private var _IOErrorText:String;	private var _urlloader:URLLoader;	private var _loadQueue:TextureLoadQueue;	private var _loadsuccess:Loader3DEvent;	private var _loaderror:Loader3DEvent;	private var _loadprogress:Loader3DEvent;		private function registerURL(object:Object3D):Void	{		if (FastStd.is(object, ObjectContainer3D)) {			for (_child in Lib.as(object, ObjectContainer3D).children)				registerURL(_child);		} else if (FastStd.is(object, Mesh)) {			Lib.as(object, Mesh).url = url;		}	}		private function initTexturePath():Void	{		//set texturePath to default if no texturePath detected		if (texturePath == "" && url != null) {			var pathArray:Array<String> = url.split("/");			pathArray.pop();			texturePath = (pathArray.length > 0) ? (pathArray.join("/") + "/") : (pathArray.join("/"));		}	}		private function notifySuccess():Void	{		mode = COMPLETE;				_result = _object;				_result.transform.matrix3D = transform.matrix3D.clone();		_result.name = name;		//_result.ownCanvas = ownCanvas;		//_result.renderer = renderer;		_result.filters = filters.concat([]);		_result.blendMode = blendMode;		_result.alpha = alpha;		_result.visible = visible;		_result.mouseEnabled = mouseEnabled;		_result.useHandCursor = useHandCursor;		//_result.pushback = pushback;		//_result.pushfront = pushfront;		//_result.screenZOffset = screenZOffset;		//_result.pivotPoint = pivotPoint;		//_result.extra = (extra is IClonable) ? (extra as IClonable).clone() : extra;				if (parent != null) {			parent.addChild(_result);			parent.removeChild(this);		}				//register url with hierarchy		registerURL(_result);				//dispatch event		if (_loadsuccess == null)			_loadsuccess = new Loader3DEvent(Loader3DEvent.LOAD_SUCCESS, this);					dispatchEvent(_loadsuccess);	}		private function notifyError():Void	{		//dispatch event		if (_loaderror == null)			_loaderror = new Loader3DEvent(Loader3DEvent.LOAD_ERROR, this);				dispatchEvent(_loaderror);	}		private function notifyProgress():Void	{		//dispatch event		if (_loadprogress == null)			_loadprogress = new Loader3DEvent(Loader3DEvent.LOAD_PROGRESS, this);				dispatchEvent(_loadprogress);	}		/**	* Automatically fired on an geometry error event.	* 	* @see away3dlite.loaders.utils.TextureLoadQueue	*/	private function onGeometryError(event:IOErrorEvent):Void	{		_IOErrorText = event.text;		notifyError();	}		/**	* Automatically fired on a geometry progress event	*/	private function onGeometryProgress(event:ProgressEvent):Void	{		_bytesLoaded = event.bytesLoaded;		_bytesTotal = event.bytesTotal;		notifyProgress();	}		/**	* Automatically fired on a geometry complete event	*/	private function onGeometryComplete(event:Event):Void	{		loadTextures(_urlloader.data, parser);	}		/**	* Automatically fired on an parser error event.	* 	* @see away3dlite.loaders.utils.TextureLoadQueue	*/	private function onParserError(event:ParserEvent):Void	{		notifyError();	}		/**	* Automatically fired on a parser progress event	*/	private function onParserProgress(event:ParserEvent):Void	{		notifyProgress();	}		/**	* Automatically fired on a parser complete event	*/	private function onParserComplete(event:ParserEvent):Void	{		_object = event.result;		materialLibrary = _object.materialLibrary;				if (materialLibrary != null && autoLoadTextures && materialLibrary.loadRequired) {			materialLibrary.texturePath = texturePath;			mode = LOADING_TEXTURES;						_loadQueue = new TextureLoadQueue();			for (_materialData in materialLibrary)			{				if (_materialData.materialType == MaterialData.TEXTURE_MATERIAL && _materialData.material == null)				{					var req:URLRequest = new URLRequest(texturePath + _materialData.textureFileName);					var loader:TextureLoader = new TextureLoader();										_loadQueue.addItem(loader, req);				}			}			_loadQueue.addEventListener(IOErrorEvent.IO_ERROR, onTextureError);			_loadQueue.addEventListener(ProgressEvent.PROGRESS, onTextureProgress);			_loadQueue.addEventListener(Event.COMPLETE, onTextureComplete);			_loadQueue.start();		} else {			notifySuccess();		}	}		/**	* Automatically fired on an texture error event.	* 	* @see away3dlite.loaders.utils.TextureLoadQueue	*/	private function onTextureError(event:IOErrorEvent):Void	{		_IOErrorText = event.text;		notifyError();				// appear wire material instead		//materialLibrary.texturesLoaded(_loadQueue);				// it success anyway but without material		//notifySuccess(event);	}		/**	* Automatically fired on a texture progress event	*/	private function onTextureProgress(event:ProgressEvent):Void	{		_bytesLoaded = event.bytesLoaded;		_bytesTotal = event.bytesTotal;		notifyProgress();		dispatchEvent(event);	}		/**	* Automatically fired on a texture complete event	*/	private function onTextureComplete(event:Event):Void	{		materialLibrary.texturesLoaded(_loadQueue);				notifySuccess();	}		/**	* Constant value string representing the geometry loading mode of the 3d object loader.	*/	public inline static var LOADING_GEOMETRY:String = "loading_geometry";		/**	* Constant value string representing the geometry parsing mode of the 3d object loader.	*/	public inline static var PARSING_GEOMETRY:String = "parsing_geometry";		/**	* Constant value string representing the texture loading mode of the 3d object loader.	*/	public inline static var LOADING_TEXTURES:String = "loading_textures";		/**	* Constant value string representing a completed loader mode.	*/	public inline static var COMPLETE:String = "complete";		/**	* Returns the current loading mode of the 3d object loader.	*/	public var mode:String;		/**	* Returns the the data container being used by the loaded file.	*/	public var containerData:ContainerData;		/**	 * Defines a different path for the location of image files used as textures in the model. Defaults to the location of the loaded model file.	 */	public var texturePath:String;		/**	 * Controls the automatic loading of image files used as textures in the model. Defaults to true.	 */	public var autoLoadTextures:Bool;		/**	 * Returns a 3d object relating to the currently visible model.	 * While a file is being loaded, this takes the form of the 3d object loader placeholder.	 * The default placeholder is <code>LoaderCube</code>	 * 	 * Once the file has been loaded and is ready to view, the <code>handle</code> returns the 	 * parsed 3d object file and the placeholder object is swapped in the scenegraph tree.	 * 	 * @see	away3dlite.loaders.LoaderCube	 */	public var handle(get_handle, null):Object3D;	private function get_handle():Object3D	{		return (_result != null) ? _result : this;	}		public var bytesLoaded(get_bytesLoaded, null):Int;	private function get_bytesLoaded():Int	{		return _bytesLoaded;	}		public var bytesTotal(get_bytesTotal, null):Int;	private function get_bytesTotal():Int	{		return _bytesTotal;	}		public var IOErrorText(get_IOErrorText, null):String;	private function get_IOErrorText():String	{		return _IOErrorText;	}		/**	 * Creates a new <code>Loader3D</code> object.	 * 	 * @param	init	[optional]	An initialisation object for specifying default instance properties.	 */	public function new() 	{		super();				autoLoadTextures = true;		texturePath = "";	}		/**	 * Loads and parses a 3d file format.	 * 	 * @param	url			The url location of the file to be loaded.	 * @param	parser		The parser class to be used on the file data once loaded.	 */	public function loadGeometry(url:String, parser:AbstractParser):Void	{		mode = LOADING_GEOMETRY;				initTexturePath();				this.url = url;		this.parser = parser;				_urlloader = new URLLoader();		_urlloader.dataFormat = parser.arcaneNS().binary ? URLLoaderDataFormat.BINARY : URLLoaderDataFormat.TEXT;		_urlloader.addEventListener(IOErrorEvent.IO_ERROR, onGeometryError);		_urlloader.addEventListener(ProgressEvent.PROGRESS, onGeometryProgress);		_urlloader.addEventListener(Event.COMPLETE, onGeometryComplete);		_urlloader.load(new URLRequest(url));			}		/**	 * Parses 3d file data and loads any subsequent textures if required.	 * 	 * @param	data		The file data to be parsed. Can be in text or binary form.	 * @param	parser		The parser class to be used on the file data.	 */	public function loadTextures(data:Dynamic, parser:AbstractParser):Void	{		mode = PARSING_GEOMETRY;				initTexturePath();				//prepare data		this.parser = parser;				parser.addOnSuccess(onParserComplete);		parser.addOnError(onParserError);		parser.addOnProgress(onParserProgress);		parser.parseGeometry(data);	}}